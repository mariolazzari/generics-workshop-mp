#!/usr/bin/env node

// src/command.ts
import { Command } from "commander";

// src/detectExerciseType.ts
import fs from "fs/promises";
import path from "path";
var endsWithTsOrTsx = (filepath) => filepath.endsWith(".ts") || filepath.endsWith(".tsx");
var isDir = async (filepath) => {
  const stat2 = await fs.stat(filepath);
  return stat2.isDirectory();
};
var detectExerciseType = async (filepath) => {
  if (endsWithTsOrTsx(filepath)) {
    return "file";
  }
  if (await isDir(filepath)) {
    const packageJsonPath = path.resolve(filepath, "package.json");
    try {
      const packageJson = await fs.readFile(packageJsonPath, "utf-8");
      const parsed = JSON.parse(packageJson);
      if (parsed?.scripts?.dev) {
        return "package-json-with-dev-script";
      }
    } catch (e) {
    }
  }
  return "not-runnable";
};

// src/findAllExercises.ts
import * as fg from "fast-glob";
import { readdir } from "fs/promises";
import path2 from "path";
var searchToGlob = (search) => {
  return `**/${search?.num ?? ""}*.{${search?.allowedTypes?.join(",") ?? ""}}*`;
};
var findExerciseInCwd = async (exercise, runSolution) => {
  const srcPath = path2.resolve(process.cwd(), "./src");
  const exerciseFile = await findExercise(srcPath, {
    num: exercise,
    allowedTypes: ["explainer", runSolution ? "solution" : "problem"]
  });
  if (!exerciseFile) {
    console.log(`Exercise ${exercise} not found`);
    process.exit(1);
  }
  return exerciseFile;
};
var findAllSections = async (srcPath) => {
  const dirContents = await readdir(srcPath);
  const allSections = [];
  const exercises = await findAllExercises(srcPath, {
    allowedTypes: ["explainer", "problem", "solution"]
  });
  for (const dir of dirContents) {
    if (await isDir(path2.join(srcPath, dir))) {
      const pathToSection = path2.join(srcPath, dir);
      allSections.push({
        name: dir,
        files: exercises.filter((exercise) => {
          return exercise.startsWith(pathToSection);
        })
      });
    }
  }
  return {
    sections: allSections.sort((a, b) => a.name.localeCompare(b.name)),
    // If there is anything else in the src directory that is not a dir,
    // then this is not a 'section' repo
    isASectionRepo: allSections.length === dirContents.length
  };
};
var findAllExercises = async (srcPath, search) => {
  const glob = searchToGlob(search || {});
  const allExercises = await fg.default(
    path2.join(srcPath, "**", glob).replace(/\\/g, "/"),
    {
      onlyFiles: false
    }
  );
  return allExercises.sort((a, b) => a.localeCompare(b));
};
var findExercise = async (srcPath, search) => {
  const glob = searchToGlob(search);
  const allExercises = await fg.default(
    path2.join(srcPath, "**", glob).replace(/\\/g, "/"),
    {
      onlyFiles: false
    }
  );
  return allExercises[0];
};

// src/runFileBasedExercise.ts
import { execSync } from "child_process";
import * as chokidar from "chokidar";
import * as fs2 from "fs/promises";
import { parse as jsonCParse } from "jsonc-parser";
import * as path3 from "path";
var runFileBasedExercise = async (exerciseFile) => {
  const tempTsconfigPath = path3.resolve(process.cwd(), "./tsconfig.temp.json");
  const tsconfigPath = path3.resolve(process.cwd(), "./tsconfig.json");
  const tsconfig = jsonCParse(await fs2.readFile(tsconfigPath, "utf8"));
  chokidar.watch(exerciseFile).on("all", async () => {
    const fileContents = await fs2.readFile(exerciseFile, "utf8");
    const containsVitest = fileContents.includes(`from "vitest"`) || fileContents.includes(`from 'vitest'`);
    try {
      console.clear();
      if (containsVitest) {
        console.log("Running tests...");
        execSync(`vitest run "${exerciseFile}" --passWithNoTests`, {
          stdio: "inherit"
        });
      }
      console.log("Checking types...");
      const tsconfigWithIncludes = {
        ...tsconfig,
        include: [exerciseFile]
      };
      await fs2.writeFile(
        tempTsconfigPath,
        JSON.stringify(tsconfigWithIncludes, null, 2)
      );
      execSync(`tsc --project "${tempTsconfigPath}"`, {
        stdio: "inherit"
      });
      console.log("Typecheck complete. You finished the exercise!");
    } catch (e) {
      console.log("Failed. Try again!");
    } finally {
      try {
        await fs2.rm(tempTsconfigPath);
      } catch (e) {
      }
    }
  });
};

// src/runPackageJsonExercise.ts
import { execSync as execSync2 } from "child_process";
var runPackageJsonExercise = async (exerciseFile) => {
  execSync2("pnpm install", {
    cwd: exerciseFile,
    stdio: "inherit"
  });
  execSync2("pnpm run dev", {
    cwd: exerciseFile,
    stdio: "inherit"
  });
};

// src/runExercise.ts
var runExercise = async (exercise, runSolution) => {
  if (!exercise) {
    console.log("Please specify an exercise");
    process.exit(1);
  }
  const exerciseFile = await findExerciseInCwd(exercise, runSolution);
  await runExerciseFile(exerciseFile);
};
var runExerciseFile = async (exercisePath) => {
  const exerciseType = await detectExerciseType(exercisePath);
  if (exerciseType === "not-runnable") {
    console.log(`This exercise doesn't need the CLI.`.bold);
    console.log(
      ` - ` + `You haven't done anything wrong!`.bold + ` Your setup is working correctly.`
    );
    console.log(
      ` - But this exercise doesn't require the CLI to be run to complete it.`
    );
    console.log(
      ` - Instead, ` + `follow the instructions in the video`.bold + ` to complete the exercise.`
    );
    process.exit(0);
  }
  switch (exerciseType) {
    case "file":
      return await runFileBasedExercise(exercisePath);
    case "package-json-with-dev-script":
      return await runPackageJsonExercise(exercisePath);
  }
  exerciseType;
};

// src/prepareStackblitz.ts
import * as fs3 from "fs/promises";
import * as path4 from "path";
var getPackageJsonScript = (exercise, type) => {
  return [`tt-cli run ${exercise} ${type === "solution" ? "--solution" : ""}`].join(" && ").trim();
};
var prepareStackblitz = async () => {
  const packageJsonPath = path4.resolve(process.cwd(), "package.json");
  const packageJson = JSON.parse(await fs3.readFile(packageJsonPath, "utf8"));
  const srcPath = path4.resolve(process.cwd(), "./src");
  const exerciseFiles = await findAllExercises(srcPath, {
    allowedTypes: ["problem", "explainer"]
  });
  const exerciseNumbers = exerciseFiles.map(
    (exercise) => path4.parse(exercise).base.split("-")[0]
  );
  const newPackageJson = Object.assign({}, packageJson);
  newPackageJson.scripts = {
    ...packageJson.scripts
  };
  const scriptsWeControl = Object.keys(packageJson.scripts).filter((script) => {
    return script.startsWith("e-") || script.startsWith("s-");
  });
  scriptsWeControl.forEach((script) => {
    delete newPackageJson.scripts[script];
  });
  exerciseNumbers.forEach((exerciseNumber) => {
    newPackageJson.scripts[`e-${exerciseNumber}`] = getPackageJsonScript(
      exerciseNumber,
      "exercise"
    );
    newPackageJson.scripts[`s-${exerciseNumber}`] = getPackageJsonScript(
      exerciseNumber,
      "solution"
    );
  });
  await fs3.writeFile(packageJsonPath, JSON.stringify(newPackageJson, null, 2));
};

// src/snapshotExercises.ts
import { execSync as execSync4 } from "child_process";
import "colors";
import { readFileSync, writeFileSync } from "fs";
import { stat } from "fs/promises";
import * as path6 from "path";

// src/cleanVitestOutput.ts
import path5 from "path";
var cleanInput = (input) => {
  const firstCurlyBracketIndex = input.indexOf("{");
  const lastCurlyBracketIndex = input.lastIndexOf("}");
  if (firstCurlyBracketIndex === -1 || lastCurlyBracketIndex === -1) {
    throw new Error("No curly bracket found");
  }
  return input.substring(firstCurlyBracketIndex, lastCurlyBracketIndex + 1);
};
var cleanVitestOutput = (result, context) => {
  const asJson = JSON.parse(cleanInput(result));
  delete asJson.startTime;
  delete asJson.numFailedTestSuites;
  delete asJson.numFailedTests;
  delete asJson.numPassedTestSuites;
  delete asJson.numPassedTests;
  delete asJson.numPendingTestSuites;
  delete asJson.numPendingTests;
  delete asJson.numTodoTests;
  delete asJson.numTotalTestSuites;
  delete asJson.numTotalTests;
  asJson.testResults.forEach((testResult) => {
    delete testResult.startTime;
    delete testResult.endTime;
    testResult.name = path5.relative(context.rootFolder, testResult.name);
    testResult.assertionResults.forEach((assertionResult) => {
      delete assertionResult.duration;
      delete assertionResult.failureMessages;
    });
  });
  asJson.testResults.sort((a, b) => a.name.localeCompare(b.name));
  return asJson;
};

// src/install.ts
import {
  execSync as execSync3
} from "child_process";
var npx = (cmd, opts) => {
  return execSync3(`npx ${cmd}`, opts);
};

// src/snapshotExercises.ts
var getTSSnapshotFromFolder = (folder) => {
  let result;
  try {
    result = npx(`tsc`, {
      cwd: folder
    }).toString();
  } catch (error) {
    result = error.output.toString();
  }
  return result;
};
var getTSSnapshotFromFolderExercises = async (rootFolder) => {
  const srcPath = path6.resolve(rootFolder, "./src");
  const exercises = await findAllExercises(srcPath, {
    allowedTypes: ["problem", "explainer", "solution"]
  });
  const exercisesWhichAreFolders = [];
  for (const filePath of exercises) {
    if (await isDir(filePath)) {
      try {
        const tsconfigPath = path6.resolve(filePath, "tsconfig.json");
        if (await stat(tsconfigPath)) {
          exercisesWhichAreFolders.push(filePath);
        }
      } catch (e) {
      }
    }
  }
  let snapshots = [];
  for (const exerciseFolder of exercisesWhichAreFolders) {
    const tsSnapshot = getTSSnapshotFromFolder(exerciseFolder);
    snapshots.push({
      title: exerciseFolder,
      content: tsSnapshot
    });
  }
  return snapshots.reduce((acc, snapshot) => {
    return [
      acc,
      "",
      `# [](${path6.relative(
        rootFolder,
        path6.join(snapshot.title, "tsconfig.json")
      )})`,
      "",
      "```txt",
      snapshot.content,
      "```"
    ].join("\n");
  }, "");
};
var getTSSnapshot = async (rootFolder) => {
  const rootTSSnapshot = getTSSnapshotFromFolder(rootFolder);
  const tsSnapshotFromFolderExercises = await getTSSnapshotFromFolderExercises(
    rootFolder
  );
  return [
    `# Root TSConfig Snapshot`,
    "",
    "```txt",
    rootTSSnapshot,
    "```",
    "",
    tsSnapshotFromFolderExercises
  ].join("\n");
};
var getVitestSnapshot = (rootFolder) => {
  let result;
  try {
    result = npx(`vitest run --reporter=json`, {
      cwd: rootFolder,
      stdio: "pipe"
    }).toString();
  } catch (error) {
    result = error.output.toString();
  }
  const vitestOutput = cleanVitestOutput(result, {
    rootFolder
  });
  return [
    `# Vitest Snapshot`,
    "",
    "```json",
    JSON.stringify(vitestOutput, null, 2),
    "```"
  ].join("\n");
};
var getSnapshot = async () => {
  const tsSnapshot = await getTSSnapshot(process.cwd());
  const vitestSnapshot = getVitestSnapshot(process.cwd());
  const fullSnapshot = tsSnapshot + "\n\n" + vitestSnapshot;
  return fullSnapshot;
};
var takeSnapshot = async (outPath) => {
  const fullSnapshot = await getSnapshot();
  writeFileSync(outPath, fullSnapshot);
};
var compareSnapshotAgainstExisting = async (outPath) => {
  const newSnapshot = await getSnapshot();
  const existingSnapshot = readFileSync(outPath, "utf8");
  if (newSnapshot !== existingSnapshot) {
    execSync4(`git add ${outPath}`, { stdio: "inherit" });
    writeFileSync(outPath, newSnapshot);
    console.log("Snapshots differ. Showing diff:");
    execSync4(`git --no-pager diff --unified=0 ${outPath}`, { stdio: "inherit" });
    process.exit(1);
  }
};

// src/runPrompts.ts
import prompts from "prompts";
import path7 from "path";
var runPrompts = async () => {
  const srcPath = path7.resolve(process.cwd(), "./src");
  const exercises = await findAllExercises(srcPath, {
    allowedTypes: ["explainer", "problem", "solution"]
  });
  const { exercisePath } = await prompts({
    type: "autocomplete",
    message: "Select an exercise file to run (type to autocomplete)",
    name: "exercisePath",
    async suggest(input, choices) {
      return choices.filter((choice) => {
        return choice.title.toLowerCase().includes(input.toLowerCase());
      });
    },
    choices: exercises.map((exercise) => {
      const exerciseName = path7.basename(exercise);
      return {
        title: exerciseName,
        value: exercise
      };
    })
  });
  await runExerciseFile(exercisePath);
};

// package.json
var package_default = {
  name: "@total-typescript/exercise-cli",
  version: "0.11.0",
  description: "",
  type: "module",
  packageManager: "pnpm@9.3.0",
  main: "dist/bin.js",
  bin: {
    "tt-cli": "./dist/bin.js"
  },
  files: [
    "dist",
    "CHANGELOG.md"
  ],
  scripts: {
    dev: 'pnpm run "/dev:/"',
    "dev:esbuild": "pnpm run build --watch",
    "dev:tsc": "tsc --watch --preserveWatchOutput",
    test: "vitest",
    build: "esbuild --bundle src/bin.ts --platform=node --outfile=dist/bin.js --packages=external --format=esm",
    ci: "tsc && pnpm run build && vitest run",
    "local-release": 'git clean -xdf && pnpm i && changeset version && pnpm run ci && changeset publish && git add . && git commit -m "chore: release"',
    release: "pnpm run ci && changeset publish",
    "local-link": "(yarn unlink --global | true) && pnpm run build && yarn link --global"
  },
  keywords: [],
  author: "Matt Pocock",
  license: "ISC",
  peerDependencies: {
    typescript: "*",
    vitest: "*"
  },
  dependencies: {
    chokidar: "^3.5.3",
    colors: "^1.4.0",
    commander: "^10.0.1",
    "fast-glob": "^3.2.12",
    "jsonc-parser": "^3.2.0",
    prompts: "^2.4.2"
  },
  devDependencies: {
    prettier: "^3.3.2",
    "@changesets/cli": "^2.26.1",
    "@types/diff": "^5.0.4",
    "@types/node": "^20.14.9",
    "@types/prompts": "^2.4.8",
    esbuild: "^0.23.0",
    typescript: "^5.5.3",
    vitest: "^1.6.0"
  }
};

// src/create-section-repos.ts
import { execSync as execSync5 } from "child_process";
import { cpSync, mkdirSync, readdirSync, rmSync } from "fs";
import path8 from "path";
var createSectionRepos = async () => {
  const srcPath = path8.resolve(process.cwd(), "./src");
  if (!process.env.GITHUB_TOKEN) {
    console.log("Please set the GITHUB_TOKEN environment variable");
    process.exit(1);
  }
  const { sections, isASectionRepo } = await findAllSections(srcPath);
  if (!isASectionRepo) {
    console.log("This is not a section repo - not creating sections");
    process.exit(1);
  }
  const repoName = execSync5("basename $(git rev-parse --show-toplevel)").toString().trim();
  const sectionDetails = sections.map((section) => {
    const sectionNum = section.name.split("-")[0];
    return {
      num: sectionNum,
      section: section.name,
      pathToSection: path8.resolve(srcPath, section.name),
      repo: `mattpocock/${repoName}-${sectionNum}`,
      files: section.files
    };
  });
  const ROOT_FILES_TO_EXCLUDE = [
    ".github",
    ".git",
    "node_modules",
    "renovate.json",
    "out",
    ".twoslash-lint"
  ];
  execSync5("git clean -fdx");
  const rootFilesToCopy = readdirSync(process.cwd()).filter(
    (file) => !ROOT_FILES_TO_EXCLUDE.includes(file)
  );
  const relativePathsToExercises = await findAllExercises(srcPath, {
    allowedTypes: ["explainer", "solution", "problem"]
  }).then((exercises) => exercises.map((e) => path8.relative(srcPath, e)));
  for (const section of sectionDetails) {
    const repoPath = path8.resolve(process.cwd(), "out");
    try {
      mkdirSync(repoPath);
    } catch (e) {
    }
    rmSync(path8.join(repoPath, ".git"), { recursive: true, force: true });
    for (const file of rootFilesToCopy) {
      cpSync(file, path8.resolve(repoPath, file), {
        recursive: true,
        errorOnExist: false,
        force: true
      });
    }
    const relativePathsToSectionExercises = section.files.map(
      (file) => path8.relative(srcPath, file)
    );
    const exercisesToDelete = relativePathsToExercises.filter(
      (p) => !relativePathsToSectionExercises.includes(p)
    );
    execSync5(`rm -rf ${exercisesToDelete.join(" ")}`, {
      cwd: path8.join(repoPath, "src")
    });
    execSync5(`git init -b main`, { cwd: repoPath });
    execSync5(`git add .`, { cwd: repoPath });
    execSync5(`git commit -m "Initial commit"`, { cwd: repoPath });
    try {
      execSync5(`gh repo create ${section.repo} --public --source ${repoPath}`);
      execSync5(`git push -u origin main`, { cwd: repoPath });
    } catch (e) {
      const remoteUrl = `https://total-typescript-bot:${process.env.GITHUB_TOKEN}@github.com/${section.repo}.git`;
      execSync5(`git remote add origin ${remoteUrl}`, {
        cwd: repoPath
      });
      execSync5(`git fetch`, { cwd: repoPath });
      try {
        const changedFiles = execSync5(
          `git diff --name-only origin/main main --`,
          {
            cwd: repoPath
          }
        ).toString().trim();
        if (changedFiles) {
          execSync5(`git push -u origin main --force`, { cwd: repoPath });
        } else {
          console.log("No files have changed, not pushing");
        }
      } catch (e2) {
      } finally {
        execSync5(`git push -u origin main --force`, { cwd: repoPath });
      }
    }
  }
};

// src/command.ts
var totalTypeScriptCLI = new Command();
totalTypeScriptCLI.version(package_default.version);
totalTypeScriptCLI.command("run [exercise]").alias("exercise [exercise]").description("Runs an exercise on watch mode").option("-s, --solution", "Run the solution").action(
  (exercise, options) => {
    if (exercise) {
      runExercise(exercise, options.solution);
    } else {
      runPrompts();
    }
  }
);
totalTypeScriptCLI.command("create-section-repos").description("Creates section repos").action(createSectionRepos);
totalTypeScriptCLI.command("prepare-stackblitz").description("Adds e-01, e-02 scripts to package.json").action(prepareStackblitz);
totalTypeScriptCLI.command("take-snapshot <snapshotPath>").description("Takes a snapshot of the current state of the exercises").action(takeSnapshot);
totalTypeScriptCLI.command("compare-snapshot <snapshotPath>").description("Compares the current state of the exercises against a snapshot").action(compareSnapshotAgainstExisting);

// src/bin.ts
totalTypeScriptCLI.parse();
